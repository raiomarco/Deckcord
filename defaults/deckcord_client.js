window.Vencord.Plugins.plugins.Deckcord = {
  name: "Deckcord",
  description: "Plugin required for Deckcord to work",
  authors: [],
  required: true,
  startAt: "DOMContentLoaded",
  async start() {
    navigator.mediaDevices.getUserMedia = (_) =>
      new Promise(async (resolve, reject) => {
        if (
          window.MIC_STREAM != undefined &&
          window.MIC_PEER_CONNECTION != undefined &&
          window.MIC_PEER_CONNECTION.connectionState == "connected"
        ) {
          console.log("WebRTC stream available. Returning that.");
          return resolve(window.MIC_STREAM);
        }

        console.log("Starting WebRTC handshake for mic stream");
        const peerConnection = new RTCPeerConnection(null);
        window.MIC_PEER_CONNECTION = peerConnection;

        window.DECKCORD_WS.addEventListener("message", async (e) => {
          const data = JSON.parse(e.data);
          if (data.type != "$webrtc") return;

          const remoteDescription = new RTCSessionDescription(data.payload);
          await peerConnection.setRemoteDescription(remoteDescription);
        });

        peerConnection.addEventListener("icecandidate", (event) => {
          if (event.candidate) {
            window.DECKCORD_WS.send(
              JSON.stringify({ type: "$MIC_WEBRTC", ice: event.candidate })
            );
          }
        });

        peerConnection.onaddstream = (ev) => {
          const stream = ev.stream;
          console.log("WEBRTC STREAM", stream);
          window.MIC_STREAM = stream;
          for (const track of stream.getTracks()) {
            track.stop = () => {
              console.log("CALLED STOP ON TRACK");
            };
            track;
          }
          resolve(stream);
        };

        peerConnection.ontrack = (ev) => {
          ev.track.stop = () => {
            console.log("CALLED STOP ON TRACK");
          };
        };

        const offer = await peerConnection.createOffer({
          offerToReceiveVideo: false,
          offerToReceiveAudio: true,
        });
        await peerConnection.setLocalDescription(offer);
        window.DECKCORD_WS.send(
          JSON.stringify({ type: "$MIC_WEBRTC", offer: offer })
        );
      });

    function dataURLtoFile(dataurl, filename) {
      var arr = dataurl.split(","),
        mime = arr[0].match(/:(.*?);/)[1],
        bstr = atob(arr[arr.length - 1]),
        n = bstr.length,
        u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new File([u8arr], filename, { type: mime });
    }

    function patchTypingField() {
      const t = setInterval(() => {
        try {
          document.getElementsByClassName("editor__66464")[0].onclick = (e) =>
            fetch("http://127.0.0.1:65123/openkb", { mode: "no-cors" });
          clearInterval(t);
        } catch (err) {}
      }, 100);
    }

    async function getAppId(name) {
      const res = await Vencord.Webpack.Common.RestAPI.get({
        url: "/applications/detectable",
      });
      if (res.ok) {
        const item = res.body.filter((e) => e.name == name);
        if (item.length > 0) return item[0].id;
      }
      return "0";
    }

    let CloudUpload;
    CloudUpload = Vencord.Webpack.findLazy(
      (m) => m.prototype?.trackUploadFinished
    );
    function sendAttachmentToChannel(channelId, attachment_b64, filename) {
      return new Promise((resolve, reject) => {
        const file = dataURLtoFile(
          `data:text/plain;base64,${attachment_b64}`,
          filename
        );
        const upload = new CloudUpload(
          {
            file: file,
            isClip: false,
            isThumbnail: false,
            platform: 1,
          },
          channelId,
          false,
          0
        );
        upload.on("complete", () => {
          Vencord.Webpack.Common.RestAPI.post({
            url: `/channels/${channelId}/messages`,
            body: {
              channel_id: channelId,
              content: "",
              nonce: Vencord.Webpack.Common.SnowflakeUtils.fromTimestamp(
                Date.now()
              ),
              sticker_ids: [],
              type: 0,
              attachments: [
                {
                  id: "0",
                  filename: upload.filename,
                  uploaded_filename: upload.uploadedFilename,
                },
              ],
            },
          });
          resolve(true);
        });
        upload.on("error", () => resolve(false));
        upload.upload();
      });
    }

    let MediaEngineStore, FluxDispatcher;
    console.log("Deckcord: Waiting for FluxDispatcher...");
    Vencord.Webpack.waitFor(["subscribe", "dispatch", "register"], (fdm) => {
      FluxDispatcher = fdm;
      Vencord.Webpack.waitFor(
        Vencord.Webpack.filters.byStoreName("MediaEngineStore"),
        (m) => {
          MediaEngineStore = m;
          FluxDispatcher.dispatch({
            type: "MEDIA_ENGINE_SET_AUDIO_ENABLED",
            enabled: true,
            unmute: true,
          });
        }
      );

      function connect() {
        window.DECKCORD_WS = new WebSocket("ws://127.0.0.1:65123/socket");
        window.DECKCORD_WS.addEventListener("message", async (e) => {
          const data = JSON.parse(e.data);
          if (data.type.startsWith("$")) {
            let result;
            try {
              switch (data.type) {
                case "$getuser":
                  result = Vencord.Webpack.Common.UserStore.getUser(data.id);
                  break;
                case "$getchannel":
                  result = Vencord.Webpack.Common.ChannelStore.getChannel(
                    data.id
                  );
                  break;
                case "$getguild":
                  result = Vencord.Webpack.Common.GuildStore.getGuild(data.id);
                  break;
                case "$getmedia":
                  result = {
                    mute: MediaEngineStore.isSelfMute(),
                    deaf: MediaEngineStore.isSelfDeaf(),
                    live: MediaEngineStore.getGoLiveSource() != undefined,
                  };
                  break;
                case "$get_last_channels":
                  result = {};
                  const ChannelStore = Vencord.Webpack.Common.ChannelStore;
                  const GuildStore = Vencord.Webpack.Common.GuildStore;
                  const channelIds = Object.values(
                    JSON.parse(Vencord.Util.localStorage.SelectedChannelStore)
                      .mostRecentSelectedTextChannelIds
                  );
                  for (const chId of channelIds) {
                    const ch = ChannelStore.getChannel(chId);
                    const guild = GuildStore.getGuild(ch.guild_id);
                    result[chId] = `${ch.name} (${guild.name})`;
                  }
                  break;
                case "$get_screen_bounds":
                  result = { width: screen.width, height: screen.height };
                  break;
                case "$ptt":
                  try {
                    MediaEngineStore.getMediaEngine()
                      .connections.values()
                      .next()
                      .value.setForceAudioInput(data.value);
                  } catch (error) {}
                  return;
                case "$setptt":
                  FluxDispatcher.dispatch({
                    type: "AUDIO_SET_MODE",
                    context: "default",
                    mode: data.enabled ? "PUSH_TO_TALK" : "VOICE_ACTIVITY",
                    options: MediaEngineStore.getSettings().modeOptions,
                  });
                  return;
                case "$rpc":
                  FluxDispatcher.dispatch({
                    type: "LOCAL_ACTIVITY_UPDATE",
                    activity: data.game
                      ? {
                          application_id: await getAppId(data.game),
                          name: data.game,
                          type: 0,
                          flags: 1,
                          timestamps: { start: Date.now() },
                        }
                      : {},
                    socketId: "CustomRPC",
                  });
                  return;
                case "$screenshot":
                  result = await sendAttachmentToChannel(
                    data.channel_id,
                    data.attachment_b64,
                    "screenshot.jpg"
                  );
                  break;
                case "$golive":
                  const vc_channel_id = Vencord.Webpack.findStore(
                    "SelectedChannelStore"
                  ).getVoiceChannelId();
                  if (!vc_channel_id) return;
                  const vc_guild_id =
                    Vencord.Webpack.Common.ChannelStore.getChannel(
                      vc_channel_id
                    ).guild_id;
                  if (data.stop)
                    Vencord.Webpack.wreq(799808).default(null, null, null);
                  else
                    Vencord.Webpack.wreq(799808).default(
                      vc_guild_id,
                      vc_channel_id,
                      "Activity Panel"
                    );
                  return;
                case "$webrtc":
                  return;
              }
            } catch (error) {
              result = { error: error };
              if (data.increment == undefined) return;
            }
            const payload = {
              type: "$deckcord_request",
              increment: data.increment,
              result: result || {},
            };
            console.debug(data, payload);
            window.DECKCORD_WS.send(JSON.stringify(payload));
            return;
          }
          FluxDispatcher.dispatch(data);
        });

        window.DECKCORD_WS.onopen = (e) => {
          navigator.mediaDevices.getUserMedia();
          Vencord.Webpack.waitFor("useState", (t) =>
            window.DECKCORD_WS.send(
              JSON.stringify({
                type: "LOADED",
                result: true,
              })
            )
          );
        };

        window.DECKCORD_WS.onclose = (e) => {
          FluxDispatcher._interceptors.pop();
          setTimeout(() => {
            connect();
          }, 100);
        };

        window.DECKCORD_WS.onerror = (err) => {
          console.error(
            "Socket encountered error: ",
            err.message,
            "Closing socket"
          );
          window.DECKCORD_WS.close();
        };

        Vencord.Webpack.onceReady.then((t) =>
          window.DECKCORD_WS.send(
            JSON.stringify({
              type: "CONNECTION_OPEN",
              user: Vencord.Webpack.Common.UserStore.getCurrentUser(),
            })
          )
        );

        FluxDispatcher.addInterceptor((e) => {
          if (e.type == "CHANNEL_SELECT") patchTypingField();
          const shouldPass = [
            "CONNECTION_OPEN",
            "LOGOUT",
            "CONNECTION_CLOSED",
            "VOICE_STATE_UPDATES",
            "VOICE_CHANNEL_SELECT",
            "AUDIO_TOGGLE_SELF_MUTE",
            "AUDIO_TOGGLE_SELF_DEAF",
            "RPC_NOTIFICATION_CREATE",
            "STREAM_START",
            "STREAM_STOP",
          ].includes(e.type);
          if (shouldPass) {
            console.log("Dispatching Deckcord event: ", e);
            window.DECKCORD_WS.send(JSON.stringify(e));
          }
        });
        console.log("Deckcord: Added event interceptor");
      }
      connect();
    });

    (() => {
      const t = setInterval(() => {
        try {
          if (window.location.pathname == "/login") {
            for (const el of document.getElementsByTagName("input")) {
              el.onclick = (ev) =>
                fetch("http://127.0.0.1:65123/openkb", { mode: "no-cors" });
            }
          }
          clearInterval(t);
        } catch (err) {}
      }, 100);
    })();
  },
};
